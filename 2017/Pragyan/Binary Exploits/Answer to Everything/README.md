# Challenge

> Shal has got a binary. It contains the name of a wise man and his flag. He is unable to solve it.
> 
> Submit the flag to unlock the secrets of the universe.
> 
> * [main.exe](attachments/main.exe), MD5 file hash: `753097f903bc7165a5fb139dd12959d4`

# Solution

In this challenge we are given a very terse clue referencing someone named "Shal" and an unnamed "wise man," along with a single file to download. The file is called `main.exe`. By convention, a file whose name ends with [`.exe` is expected to be a certain kind of executable file](https://en.wikipedia.org/wiki/EXE), that is, a program written so that it can be run on a version of the [Microsoft Windows](https://simple.wikipedia.org/wiki/Microsoft_Windows) or another operating system. Executable files are often also called "binaries" in computer jargon. As per the challenge category ("[binary exploitation](https://trailofbits.github.io/ctf/exploits/binary1.html)"), we can expect that we must recover the flag by making this program do something it may not have been designed to do.

> :beginner: :warning: Before you read any further, you need to know that it's *very dangerous* to handle executable files that you don't recognize. The (correct) common sense advice is **do not run software that you got from strangers.** Sure, during a CTF, it's *usually* the case that applications are harmless, because the whole point of the CTF is that it's a fun puzzle game. However, these programs are still *executable*, and that means they can still do anything any other program can do, including installing malware, spreading viruses, implanting rootkits, setting up backdoors into your computer, and a lot of other scary things. These programs are still *real* programs that, if you execute them, you are *actually* running them.
> 
> Given the danger, what are you to do if all you've got to work with is an executable file? The solution is to use the digital equivalent of a [cleanroom](https://en.wikipedia.org/wiki/Cleanroom), an environment that you can control and contain any "contamination" that may result from running programs that you don't trust. One very good and very convenient way to do this is to use a [virtual machine](https://simple.wikipedia.org/wiki/Virtual_machine). As the name implies, these are special programs that emulate a real computer system, but completely isolate the virtualized system (the "guest" machine) from your real one (the "host" machine). Since they are just a software program, and not a physical computer, you can safely expose them to possible infection and easily restore their original, uninfected state with the click of a mouse. Everything you'll read about in the remainder of this write-up was performed inside virtual machines, for this exact reason.
> 
> If you've never used a virtual machine (a "VM") before, I suggest you pause here and familiarize yourself with one or more virtual machine management systems (called "hypervisors") before you continue. One of the most popular VM hypervisors is called [VirtualBox](https://www.virtualbox.org/). It's free, it's reliable, and it runs well on macOS, GNU/Linux, and Windows computers. The [VirtualBox manual details its installation procedure](https://www.virtualbox.org/manual/ch02.html) on each of these host operating systems.

## Executing the file on a Windows VM

Perhaps the most obvious thing we can do when all we have is an executable file is to run it and see what happens. Given its name, we might expect to be able to run this `main.exe` program on a Windows computer. However, double-clicking on it or running it from a command prompt immediately reveals a problem:

![Screenshot of attempting to run the main.exe program and seeing an error.](screenshots/windows-runtime-error.png)

Instead of successfully running the program, we are greeted with a Windows error message that says the "CPU has encountered an illegal instruction." The two buttons available to us, *Close* or *Ignore*, don't seem to present any obvious way forward. If we close the application, we are simply quitting it immediately. Clicking on *Ignore* simply gives us the same error again, this time with slightly different details on the last line of the error (the cryptic one that reads "CS:0576 IP:045d OP:63 61 6e 66 00").

An "illegal instruction" is serious. It means the computer didn't understand what the executable wanted it to do; whatever instruction was in the file wasn't one the computer understood how to take. Let's have several increasingly closer looks at the file itself, and the instructions contained within it, to learn why.

The most basic of all possible examinations we can perform is to use [Windows's command prompt](http://www.computerhope.com/issues/chusedos.htm)'s [`type` command](https://technet.microsoft.com/en-us/library/bb491026.aspx) to show us the contents of the file as though it were just a bunch of text:

```
C:\Users\Public\tmp>type main.exe
⌂ELF☻☺☺         ☻ > ☺   α♦@     @       P
C:\Users\Public\tmp>
```

What's useful in this output is near the very beginning: the text `ELF` is not what we would expect for a Windows executable. It's actually what we'd expect for a *GNU/Linux* program. That's because the content of most files, including executable files, are structured in a well-known way to ensure that a file created on one computer can still be read and understood when moved to another. This usually means that the contents of files start with a specific sequence of binary data depending on the type of file it is intended to be. Other computers are pre-programmed to recognize certain sequences. A Windows computer recognizes the sequence that means "I am a Windows executable," but it does *not* recognize the sequence that means, "I am a GNU/Linux program." The term for this sequence is a "[file magic number](http://www.astro.keele.ac.uk/oldusers/rno/Computing/File_magic.html)," or sometimes a "[file signature](https://en.wikipedia.org/wiki/List_of_file_signatures)," and they're almost always found at the very beginning of a file, a position sometimes called the *file format header.*

Given that, if the `main.exe` file were really a Windows executable we would [expect to see the two letters `MZ` at the very beginning](https://en.wikipedia.org/wiki/DOS_MZ_executable) of `type`'s output. For example, here's what doing the same thing with Windows's built-in [Notepad](https://en.wikipedia.org/wiki/Microsoft_Notepad) program looks like:

```
C:\Users\Public\tmp>type C:\Windows\System32\notepad.exe
MZÉ ♥   ♦       ╕       @                                   α   ♫▼║♫ ┤  ═!╕☺L═!T
his program cannot be run in DOS mode.
$       ▓╛┬b÷▀¼1÷▀¼1÷▀¼1 º91⌡▀¼1 º?1δ▀¼1÷▀¡1 ▀¼1 º/1Θ▀¼1 º(1⌠▀¼1 º81≈▀¼1 º=1≈▀¼1
Rich÷▀¼1                PE  L☺♦ ☼╞[J        α ☻☺♂☺        ¿   $☻     ë6   ►   └
    ☺ ►   ☻  ♠ ☺ ♠ ☺ ♠ ☺       ♥  ♦  Aù♥ ☻ @ü  ♦  ►☺   ►  ►      ►           Há
 ,☺   ≡  `±☺                  ≡☻ 4♫  ,╢  8                           Xm  @   x☻
 (☺   ►   ♦                          .text   îª   ►   ¿   ♦                 `.da
ta   d!   └   ►   ¼              @  └.rsrc   `±☺  ≡   ≥☺  ╝              @  @.re
loc  4♫   ≡☻  ►   «☻             @  B~┘[JÇ   ¡┌[Jì ☺ █┌[JÜ   ▌┘[Jñ   /█[J«   o┌[
☺  █┌[JÜ   +█[J[J╤   K█[J▌   ╟┌[JΩ   ♣█[J⌠   v┘[J ☺  ╩┌[J
C:\Users\Public\tmp>
```

As expected, `MZ` is at the very beginning of the output we receive from `type`. It's now clear that the `main.exe` file, despite its name, has nothing to do with Windows at all. The fact that the filename ends with "`.exe`" is an attempt to distract from the real format of the file, which we know is a GNU/Linux program because its file magic says so. Our takeaway is that file extensions are just conventions. What really matters to a computer is the file's actual contents.

> :beginner: The reason the rest of `type`'s output seems garbled is because the `notepad.exe` file contains data that isn't meant to be interpreted as plain text. Using programs that *expect* plain-text input, such as `type`, we can (and we just did) nevertheless try to interpret its contents that way, but only the portions of the file that were meant to be text or the parts that just happen to mean the same thing as textual characters actually show up that way. Perhaps a more illustrative example is what happens when we open the `main.exe` file with Notepad itself:
> 
> ![Screenshot of opening the main.exe file in the Notepad text editor.](screenshots/notepad-showing-linux-binary.png)
> 
> Here you can clearly see similarly-garbled output. However, if you look closely, you will see some recognizable strings, such as the word `linux` near several references to `GNU`. Given that the file's magic reads "`ELF`," finding strings that reference GNU/Linux is now no longer a surprise.
> 
> Moreover, this also demonstrates that a file is simply a container for some data. You can choose to interpret its data in any number of ways, even in ways the creator of the file didn't intend. Trying to read a file—any file—as though it were text is a fast, simple way to look at the file's contents without the risk of interpreting the file's contents as program instructions for your computer to execute.

Now that we've seen some evidence that we're barking up the wrong tree with Windows, let's copy this file over to a GNU/Linux machine and keep poking at it.

## The `file` command on GNU/Linux and it's "magic"

The next-most sophisticated tool we can use to examine the file is [the `file(1)` command](https://linux.die.net/man/1/file), available by default on any modern GNU/Linux system. This utility performs a mind-numbing number of tests against a file that you give it in an attempt to determine exactly what kind of file it is. One of those tests is the one we've just performed ourselves: read a file's magic signature. However, `file` does a lot more than that. When we ask `file` to examine `main.exe`, we see that it, too, thinks the file is a GNU/Linux program, not a Windows one:

```sh
$ file main.exe
main.exe: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=4b9b47b7eac612e0c367f0e3a9878eb1f09b841d, not stripped, with debug_info
```

So `file` clearly reports the file is "executable" and that it's "for GNU/Linux," which we already knew. But it goes further, even giving us a version ("2.6.32"). It's worth taking some time to understand how `file` was able to do all this. This will also help us further understand the original error that Windows threw up.

### First steps reading binary data

As you know, everything on a computer is just "a series of ones and zeros." One way to see the ones and zeros themselves is to use another [GNU/Linux command called `xxd(1)`](https://linux.die.net/man/1/xxd). This command shows us the contents of files as a stream of numbers, the same way that the `file` command sees them. We can use `xxd`'s `-b` option to show us a file's contents as raw, unadulterated binary data (instead of [hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal) data -- try leaving out the `-b` option to see the difference). The `main.exe` file is a little more than 8.5KB, or eight thousand five hundred bytes, in size. Since that's *a lot* of ones and zeros, let's ask `xxd` to show us only the first 64 bytes of the file using its `-l` option:

```sh
$ xxd -l 64 -b main.exe
0000000: 01111111 01000101 01001100 01000110 00000010 00000001  .ELF..
0000006: 00000001 00000000 00000000 00000000 00000000 00000000  ......
000000c: 00000000 00000000 00000000 00000000 00000010 00000000  ......
0000012: 00111110 00000000 00000001 00000000 00000000 00000000  >.....
0000018: 11100000 00000100 01000000 00000000 00000000 00000000  ..@...
000001e: 00000000 00000000 01000000 00000000 00000000 00000000  ..@...
0000024: 00000000 00000000 00000000 00000000 01010000 00011010  ....P.
000002a: 00000000 00000000 00000000 00000000 00000000 00000000  ......
0000030: 00000000 00000000 00000000 00000000 01000000 00000000  ....@.
0000036: 00111000 00000000 00001001 00000000 01000000 00000000  8...@.
000003c: 00011111 00000000 00011100 00000000                    ....
```

`xxd`'s output shows us three main sets of columns. Over on the far left are "line numbers," counting in [hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal). The middle set of columns shows us one byte at a time in six groups of eight bits each. Over on the far right is a textual representation of the binary data, very close to the way we saw it in Notepad or when using the Windows command prompt's `type` command. (Sequences that don't decode to [ASCII](https://en.wikipedia.org/wiki/ASCII) characters are shown as a single dot character, `.`, instead.)

> :beginner: A "byte" is just some number of bits grouped together. By nearly universal agreement, a set of exactly eight bits makes a byte. Although you can define a byte to be any other number of bits you want, there's very rarely a reason to do this unless you are building your own computer chip. You might also hear a byte described as "an 8-bit byte," which means the same thing. This "8-bit makes a byte" convention is why `xxd` groups the bits into sets of eight; each group is a single byte.

Yet again we can clearly see the "magic" sequence at the start of the output. In reality, though, there's nothing *magic* about this at all. To prove this, we can write the text "`ELF`" into a file ourselves and use `xxd` to read it back out. We will see exactly the same binary data as is represented by the "ELF" part of the `main.exe` file we're examining:

```sh
$ echo -n "ELF" > elf-magic.txt # Put the letters "ELF" into a file called "elf-magic.txt"
$ xxd -b elf-magic.txt          # Show the file's binary content.
0000000: 01000101 01001100 01000110                             ELF
```

The binary data in the file we just made is identical to the binary data in the portion of the `main.exe` file that shows up as `ELF` in `xxd`'s ASCII column. So, clearly, the letters "ELF" are just that: the letter `E`, followed by the letter `L`, and finally the letter `F`. In other words, the "magic" of all this is not in the data itself, but the *interpretation* of this data. More specifically, the computer simply sees binary numbers. Those binary numbers have, by universal agreement, eight places. To a computer, a text file with the letter E in it is represented by a file whose contents is the seven-digit long, base-2 number 1000101; in a computer's 8-bit byte binary memory, that number has a leading zero bit (`01000101`).

> :beginner: If you're unfamiliar with numbering schemes other than decimal ("base 10"), a "base-2 number" might be confusing. Likewise, if you're used to mathematics but not computer science, you might wonder why we write this number with a leading zero at all. Both are good questions.
> 
> All a "base-2" number  means is a number that, when written down, uses only the first two integers, so that each digit's position represents two times the previous position's value. The first integer is `0`, and the second is `1`, so a "base-2 number" must be written using only those two numerals. That's why these are the only two numerals you see in binary.
> 
> Representing the number zero in base-2 ("binary") is done in the same way as doing so in decimal. You simply write down `0`. Similarly, representing the number one in binary is also pretty familiar: it's done by writing down `1`. In both cases, this first digit represents the value of one: when it's `0`, we have "zero ones," and when it's `1`, we have "one ones," or simply "a value of one." However, representing the number two in binary cannot be done by writing the numeral `2`. Instead, we write `10`. Pronounced verbally, this sounds like "1 two and 0 ones," because one `2` plus `0` equals `2`. You might also hear this pronounced as "one in the 2's place and zero in the 1's place."
> 
> Notice that representing the value "two" in binary required two binary digits. In computing, we say that "takes (at least) two bits of space." We could also represent the value "three" using just those two bits of space: `11`. But notice that the value "four" requires (at least) *three* bits of space: `100`. The bigger the number we have, the more space we need to represent it. In other words, we've been varying the size of the group of bits we string together.
> 
> Now let's say we want to represent more than one number (or more than one letter). Instead of writing the number "four" in binary, we want to write down the two numbers "three" and "one" next to each other. Recall that three in binary is `11` and of course one is `1`. Let's write those down next to each other: `111`. How are we to know that this represents "one 3 and one 1" and *not* "one in the 4's place, one in the 2's place, and one in the 1's place" (i.e., a value of seven)? The answer is by agreeing, for the purpose of this example, to always read the data as groups of two bits each (2-bit bytes, that is). In this case we need to know where to put "the spaces" between each byte.
> 
> So, first, we read `11`. Okay, that's three. Then, we read `1`. Now we have another problem: it's only one bit, but we agreed to read data in groups of two bits each. So what do we do about the missing bit? Do we read this as `10`, assuming the bit we have is in the bigger position (which would make it mean the number two), or do we read this as `01` and assume the bit we have is in the smaller position (which would make it mean the number one)? And now you can see why leading zeros, when reading in computer data, matters very much!

### The ELF format

ELF stands for [Executable and Linkable Format](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format), the standard describing how to write a file in a way that GNU/Linux systems will interpret as program instructions to execute instead of something else (like a text file, or a visual picture, or an audio file). According to the ELF standard, the way you start writing [ELF-format files](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#File_header) is by making the first four bytes of such files exactly the following binary sequence of 8-bit bytes: `01111111 01000101 01001100 01000110`. The first of those bytes is the number one-hundred twenty seven (in [base-8 or octal](https://en.wikipedia.org/wiki/Octal) that's written as `177` and in hexadecimal it's `7f`). The last three of those bytes are the binary representation of the ASCII-encoded letters E, L, and F. This means that every GNU/Linux operating system has code in it that looks for this exact sequence of bits and, upon encountering it at the start of a file, *interprets the remainder of the file* according to the ELF standard.

Other programs can do this, too. The "magic" interpretation is not unique to GNU/Linux operating system code. For example, the `file` command's program code does the exact same thing; it reads a file's contents and, upon encountering this exact sequence of bits at the start of a file, reports that it has found an "ELF" file. How `file` knows about this sequence is also not magical. On one of my systems, the `file` program consults a database file called `magic` that records thousands upon thousands of file signatures, where to expect them in a given file, and what should be reported about the file if they are found. Here's a way to see what the signature, test, and report for the ELF magic looks like:

```sh
$ # Show me all lines in the file /opt/local/share/misc/magic matching
$ # the extended regular expression pattern "ELF\s*ELF"
$ grep -E "ELF\s*ELF" /opt/local/share/misc/magic
0   string      \177ELF     ELF
```

This "magic file" (the exact filesystem location may be different on your system) contains text wherein each line is a test to perform and what to print if that test is successful. The format of each line, described in [the `magic(5)` manual page](https://linux.die.net/man/5/magic), is divided into four fields. The first field is a numeric offset of where in the tested file to perform the test. In the test shown above, the offset is `0`, meaning "the start of the file." The second field is a keyword indicating how to interpret the next field. In this case, the second field is `string`, meaning that the third field should be interpreted in the same way as [the C programming language interprets its `string` data type](https://www.tutorialspoint.com/cprogramming/c_strings.htm). The third field is the "magic" number or signature itself. If the tested file's contents at the given offset exactly match the contents of the third field (`\177ELF`, in this case), then the `file` program will print the text given in the fourth and final field. This is how `file` knows to say "ELF" when it is given an ELF file.

> :beginner: If you're not familiar with C, then `\177ELF` might look rather strange. The `\177` is a [C-style octal escape sequence](https://en.wikipedia.org/wiki/Escape_sequences_in_C#Table_of_escape_sequences), meaning simply a byte value of one-hundred twenty seven, which is written as `177` in octal.

### Write your our own "magic" to deceive the `file` command

We can prove that this is how `file` works by editing a file's magic so that `file` will report something different. For instance, we know that Windows executables begin with `MZ` as their very first two bytes, so we can make `file` think that our `main.exe` file is actually a Windows executable by putting those two bytes at its very start. Conveniently, `MZ` is ASCII, so we can just [`echo`](https://linux.die.net/man/1/echo) that and immediately append the existing contents of `main.exe` after it. We'll put this new, concatenated test data into a file called `actual.exe`:

```sh
$ echo -n "MZ" | cat - main.exe > actual.exe
$ xxd -l 6 actual.exe # Double-check "MZ" now starts the actual.exe file
0000000: 4d5a 7f45 4c46                           MZ.ELF
$ file actual.exe
actual.exe: MS-DOS executable, MZ for MS-DOS
```

> :beginner: Although simple edits like these are easily accomplished using the command line tools `echo` and `cat` as shown above, sometimes it's easier to work with an interactive, graphical interface instead. However, you can't just use Notepad or a regular text editor to do this because those programs always re-interpret data as text of some kind, making editing raw binary values unneccessarily difficult and confusing. So instead of plain text editors, use special-purpose programs called hex editors.
> 
> A [hex editor](https://en.wikipedia.org/wiki/Hex_editor) is a program that lets you edit binary data easily. By representing each 8-bit byte as two hexadecimal characters, you can write hexadecimal sequences that the hex editor will interpret as literal binary values. This results in a direct bit-for-bit representation of the file's underlying data, sans interpretation, translation, or intermediate encoding. There are [*many* hex editors](https://en.wikipedia.org/wiki/Comparison_of_hex_editors) out there, and which one you choose depends largely on your personal prefence (much like regular text editors). Try some and find your favorite! :) If you're looking for inspiration, personally, I like [HxD](https://mh-nexus.de/en/hxd/) for Windows and [0xED](http://www.suavetech.com/0xed/) on macOS.

:construction: TK-TODO
